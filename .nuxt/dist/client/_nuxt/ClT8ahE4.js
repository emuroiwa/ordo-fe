import{E as d,K as k,A as v,j as N,L as j,M as x,N as l,O as P,P as L,Q as S,R as O,u as h,h as y,S as _,U as w,V as A,W as R,X as T,Y as c,Z as E}from"./Pug_bBfL.js";const B=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(t,n){return()=>y(l[t.name],t.layoutProps,n.slots)}}),C={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},W=d({name:"NuxtLayout",inheritAttrs:!1,props:C,setup(t,n){const a=k(),u=L(c),e=!u||u===v()?P():u,o=N(()=>{let s=h(t.name)??(e==null?void 0:e.meta.layout)??"default";return s&&!(s in l)&&t.fallback&&(s=h(t.fallback)),s}),i=j();n.expose({layoutRef:i});const r=a.deferHydration();if(a.isHydrating){const s=a.hooks.hookOnce("app:error",r);x().beforeEach(s)}let f;return()=>{const s=o.value&&o.value in l,p=(e==null?void 0:e.meta.layoutTransition)??S,b=f;return f=o.value,O(s&&p,{default:()=>y(w,{suspensible:!0,onResolve:()=>{_(r)}},{default:()=>y(H,{layoutProps:A(n.attrs,{ref:i}),key:o.value||void 0,name:o.value,shouldProvide:!t.name,isRenderingNewLayout:m=>m!==b&&m===o.value,hasTransition:!!p},n.slots)})}).default()}}}),H=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(t,n){const a=t.name;t.shouldProvide&&R(E,{isCurrent:e=>a===(e.meta.layout??"default")});const u=L(c);if(u&&u===v()){const e=P(),o={};for(const i in e){const r=i;Object.defineProperty(o,r,{enumerable:!0,get:()=>t.isRenderingNewLayout(t.name)?e[r]:u[r]})}R(c,T(o))}return()=>{var e,o;return!a||typeof a=="string"&&!(a in l)?(o=(e=n.slots).default)==null?void 0:o.call(e):y(B,{key:a,layoutProps:t.layoutProps,name:a},n.slots)}}});export{W as _};
