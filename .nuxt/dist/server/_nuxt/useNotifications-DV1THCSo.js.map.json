{"file":"useNotifications-DV1THCSo.js","mappings":"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","names":[],"sources":["../../../../node_modules/nuxt/dist/app/compat/interval.js","../../../../composables/useNotifications.ts"],"sourcesContent":["import { createError } from \"../composables/error.js\";\nconst intervalError = \"[nuxt] `setInterval` should not be used on the server. Consider wrapping it with an `onNuxtReady`, `onBeforeMount` or `onMounted` lifecycle hook, or ensure you only call it in the browser by checking `import.meta.client`.\";\nexport const setInterval = import.meta.client ? window.setInterval : () => {\n  if (import.meta.dev) {\n    throw createError({\n      statusCode: 500,\n      message: intervalError\n    });\n  }\n  console.error(intervalError);\n};\n","import { ref, computed, readonly, onUnmounted, type ComputedRef } from 'vue'\n\n// Nuxt auto-imports (explicit for TypeScript)\ndeclare global {\n  const useRuntimeConfig: () => any\n  const useAuth: () => any\n  const $fetch: <T = any>(url: string, options?: any) => Promise<T>\n  const navigateTo: (to: string) => Promise<void>\n}\n\n// Type definitions\nexport interface NotificationData {\n  title: string\n  message: string\n  icon?: string\n  action_url?: string\n}\n\nexport interface NotificationMetadata {\n  icon?: string\n  action_url?: string\n  [key: string]: any\n}\n\nexport interface Notification {\n  id: string\n  type: string\n  notifiable_type: string\n  notifiable_id: string\n  data: NotificationData\n  metadata?: NotificationMetadata\n  read_at: string | null\n  priority: 'low' | 'normal' | 'high' | 'urgent'\n  expires_at?: string | null\n  created_at: string\n  updated_at: string\n  // Helper methods (optional)\n  getIcon?(): string\n  getTitle?(): string\n  getMessage?(): string\n  getActionUrl?(): string | null\n}\n\nexport interface NotificationMeta {\n  current_page: number\n  last_page: number\n  per_page: number\n  total: number\n  unread_count: number\n}\n\nexport interface NotificationResponse {\n  notifications: Notification[]\n  meta: NotificationMeta\n}\n\nexport interface FetchNotificationsOptions {\n  page?: number\n  perPage?: number\n  unreadOnly?: boolean\n  type?: string\n  priority?: string\n  append?: boolean\n}\n\nexport interface BulkActionPayload {\n  action: 'mark_read' | 'mark_unread' | 'delete'\n  notification_ids: string[]\n}\n\nexport interface CreateNotificationPayload {\n  type: string\n  notifiable_type: string\n  notifiable_id: string\n  data: NotificationData\n  metadata?: NotificationMetadata\n  priority?: 'low' | 'normal' | 'high' | 'urgent'\n  expires_at?: string\n}\n\n// Global state\nconst notifications = ref<Notification[]>([])\nconst unreadCount = ref<number>(0)\nconst isLoading = ref<boolean>(false)\nconst isDropdownOpen = ref<boolean>(false)\n\nexport const useNotifications = () => {\n  const config = useRuntimeConfig()\n  const { token } = useAuth()\n\n  // Get API headers with authentication\n  const getHeaders = (): Record<string, string> => ({\n    'Authorization': `Bearer ${token.value}`,\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n    'X-Requested-With': 'XMLHttpRequest'\n  })\n\n  // Fetch all notifications with pagination\n  const fetchNotifications = async (options: FetchNotificationsOptions = {}): Promise<NotificationResponse> => {\n    if (!token.value) return { notifications: [], meta: {} as NotificationMeta }\n    \n    isLoading.value = true\n    \n    try {\n      const queryParams = new URLSearchParams({\n        page: (options.page || 1).toString(),\n        per_page: (options.perPage || 15).toString(),\n        ...(options.unreadOnly && { unread_only: 'true' }),\n        ...(options.type && { type: options.type }),\n        ...(options.priority && { priority: options.priority }),\n      })\n\n      const response = await $fetch<NotificationResponse>(`/api/v1/notifications?${queryParams}`, {\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 10000\n      })\n\n      if (options.append) {\n        notifications.value = [...notifications.value, ...response.notifications]\n      } else {\n        notifications.value = response.notifications\n      }\n      \n      unreadCount.value = response.meta.unread_count\n\n      return response\n    } catch (error) {\n      console.error('Failed to fetch notifications:', error)\n      return { notifications: [], meta: {} as NotificationMeta }\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // Fetch recent notifications for dropdown\n  const fetchRecentNotifications = async (limit: number = 5): Promise<Notification[]> => {\n    if (!token.value) return []\n    \n    try {\n      const response = await $fetch<{ notifications: Notification[], unread_count: number }>(`/api/v1/notifications/recent?limit=${limit}`, {\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      notifications.value = response.notifications\n      unreadCount.value = response.unread_count\n\n      return response.notifications\n    } catch (error) {\n      console.error('Failed to fetch recent notifications:', error)\n      return []\n    }\n  }\n\n  // Fetch unread count only\n  const fetchUnreadCount = async (): Promise<number> => {\n    if (!token.value) return 0\n    \n    try {\n      const response = await $fetch<{ unread_count: number }>('/api/v1/notifications/unread-count', {\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      unreadCount.value = response.unread_count\n      return response.unread_count\n    } catch (error) {\n      console.error('Failed to fetch unread count:', error)\n      return 0\n    }\n  }\n\n  // Mark notification as read\n  const markAsRead = async (notificationId: string): Promise<boolean> => {\n    if (!token.value) return false\n    \n    try {\n      await $fetch(`/api/v1/notifications/${notificationId}/read`, {\n        method: 'PATCH',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      // Update local state\n      const notification = notifications.value.find(n => n.id === notificationId)\n      if (notification && !notification.read_at) {\n        notification.read_at = new Date().toISOString()\n        unreadCount.value = Math.max(0, unreadCount.value - 1)\n      }\n\n      return true\n    } catch (error) {\n      console.error('Failed to mark notification as read:', error)\n      return false\n    }\n  }\n\n  // Mark notification as unread\n  const markAsUnread = async (notificationId: string): Promise<boolean> => {\n    if (!token.value) return false\n    \n    try {\n      await $fetch(`/api/v1/notifications/${notificationId}/unread`, {\n        method: 'PATCH',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      // Update local state\n      const notification = notifications.value.find(n => n.id === notificationId)\n      if (notification && notification.read_at) {\n        notification.read_at = null\n        unreadCount.value += 1\n      }\n\n      return true\n    } catch (error) {\n      console.error('Failed to mark notification as unread:', error)\n      return false\n    }\n  }\n\n  // Mark all notifications as read\n  const markAllAsRead = async (): Promise<boolean> => {\n    if (!token.value) return false\n    \n    try {\n      await $fetch('/api/v1/notifications/mark-all-read', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      // Update local state\n      notifications.value.forEach(notification => {\n        if (!notification.read_at) {\n          notification.read_at = new Date().toISOString()\n        }\n      })\n      unreadCount.value = 0\n\n      return true\n    } catch (error) {\n      console.error('Failed to mark all notifications as read:', error)\n      return false\n    }\n  }\n\n  // Delete notification\n  const deleteNotification = async (notificationId: string): Promise<boolean> => {\n    if (!token.value) return false\n    \n    try {\n      await $fetch(`/api/v1/notifications/${notificationId}`, {\n        method: 'DELETE',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        timeout: 5000\n      })\n\n      // Update local state\n      const index = notifications.value.findIndex(n => n.id === notificationId)\n      if (index !== -1) {\n        const notification = notifications.value[index]\n        if (!notification.read_at) {\n          unreadCount.value = Math.max(0, unreadCount.value - 1)\n        }\n        notifications.value.splice(index, 1)\n      }\n\n      return true\n    } catch (error) {\n      console.error('Failed to delete notification:', error)\n      return false\n    }\n  }\n\n  // Bulk actions\n  const bulkAction = async (action: 'mark_read' | 'mark_unread' | 'delete', notificationIds: string[]): Promise<any> => {\n    if (!token.value || !notificationIds.length) return false\n    \n    try {\n      const response = await $fetch('/api/v1/notifications/bulk-action', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        body: {\n          action,\n          notification_ids: notificationIds\n        } as BulkActionPayload,\n        timeout: 10000\n      })\n\n      // Update local state based on action\n      notificationIds.forEach(id => {\n        const notification = notifications.value.find(n => n.id === id)\n        if (!notification) return\n\n        switch (action) {\n          case 'mark_read':\n            if (!notification.read_at) {\n              notification.read_at = new Date().toISOString()\n              unreadCount.value = Math.max(0, unreadCount.value - 1)\n            }\n            break\n          case 'mark_unread':\n            if (notification.read_at) {\n              notification.read_at = null\n              unreadCount.value += 1\n            }\n            break\n          case 'delete':\n            const index = notifications.value.findIndex(n => n.id === id)\n            if (index !== -1) {\n              if (!notification.read_at) {\n                unreadCount.value = Math.max(0, unreadCount.value - 1)\n              }\n              notifications.value.splice(index, 1)\n            }\n            break\n        }\n      })\n\n      return response\n    } catch (error) {\n      console.error('Failed to perform bulk action:', error)\n      return false\n    }\n  }\n\n  // Create a new notification (for testing)\n  const createNotification = async (notificationData: CreateNotificationPayload): Promise<Notification | null> => {\n    if (!token.value) return null\n    \n    try {\n      const response = await $fetch<{ notification: Notification }>('/api/v1/notifications', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        headers: getHeaders(),\n        body: notificationData,\n        timeout: 5000\n      })\n\n      // Add to local state\n      notifications.value.unshift(response.notification)\n      if (!response.notification.read_at) {\n        unreadCount.value += 1\n      }\n\n      return response.notification\n    } catch (error) {\n      console.error('Failed to create notification:', error)\n      return null\n    }\n  }\n\n  // Helper functions\n  const getNotificationIcon = (notification: Notification): string => {\n    return notification.metadata?.icon || notification.getIcon?.() || 'bell'\n  }\n\n  const getNotificationTitle = (notification: Notification): string => {\n    return notification.data?.title || notification.getTitle?.() || 'Notification'\n  }\n\n  const getNotificationMessage = (notification: Notification): string => {\n    return notification.data?.message || notification.getMessage?.() || ''\n  }\n\n  const getNotificationActionUrl = (notification: Notification): string | null => {\n    return notification.metadata?.action_url || notification.getActionUrl?.() || null\n  }\n\n  const isNotificationUnread = (notification: Notification): boolean => {\n    return !notification.read_at\n  }\n\n  const getNotificationPriorityClass = (notification: Notification): string => {\n    const priority = notification.priority || 'normal'\n    return {\n      low: 'text-gray-600',\n      normal: 'text-blue-600',\n      high: 'text-orange-600',\n      urgent: 'text-red-600'\n    }[priority] || 'text-blue-600'\n  }\n\n  const formatNotificationTime = (notification: Notification): string => {\n    if (!notification.created_at) return ''\n    \n    const date = new Date(notification.created_at)\n    const now = new Date()\n    const diffMs = now.getTime() - date.getTime()\n    const diffMins = Math.floor(diffMs / 60000)\n    const diffHours = Math.floor(diffMins / 60)\n    const diffDays = Math.floor(diffHours / 24)\n\n    if (diffMins < 1) return 'Just now'\n    if (diffMins < 60) return `${diffMins}m ago`\n    if (diffHours < 24) return `${diffHours}h ago`\n    if (diffDays < 7) return `${diffDays}d ago`\n    \n    return date.toLocaleDateString()\n  }\n\n  // Auto-refresh unread count\n  let refreshInterval: NodeJS.Timeout | null = null\n  \n  const startAutoRefresh = (intervalMs: number = 60000): void => {\n    if (refreshInterval) clearInterval(refreshInterval)\n    \n    refreshInterval = setInterval(() => {\n      if (token.value) {\n        fetchUnreadCount()\n      }\n    }, intervalMs)\n  }\n\n  const stopAutoRefresh = (): void => {\n    if (refreshInterval) {\n      clearInterval(refreshInterval)\n      refreshInterval = null\n    }\n  }\n\n  // Computed values\n  const hasUnreadNotifications: ComputedRef<boolean> = computed(() => unreadCount.value > 0)\n  const unreadNotifications: ComputedRef<Notification[]> = computed(() => \n    notifications.value.filter(n => !n.read_at)\n  )\n  const readNotifications: ComputedRef<Notification[]> = computed(() => \n    notifications.value.filter(n => n.read_at)\n  )\n\n  // Toggle dropdown\n  const toggleDropdown = (): void => {\n    isDropdownOpen.value = !isDropdownOpen.value\n    \n    if (isDropdownOpen.value) {\n      fetchRecentNotifications()\n    }\n  }\n\n  const closeDropdown = (): void => {\n    isDropdownOpen.value = false\n  }\n\n  // Cleanup on unmount\n  onUnmounted(() => {\n    stopAutoRefresh()\n  })\n\n  return {\n    // State\n    notifications: readonly(notifications),\n    unreadCount: readonly(unreadCount),\n    isLoading: readonly(isLoading),\n    isDropdownOpen: readonly(isDropdownOpen),\n    \n    // Computed\n    hasUnreadNotifications,\n    unreadNotifications,\n    readNotifications,\n    \n    // Actions\n    fetchNotifications,\n    fetchRecentNotifications,\n    fetchUnreadCount,\n    markAsRead,\n    markAsUnread,\n    markAllAsRead,\n    deleteNotification,\n    bulkAction,\n    createNotification,\n    \n    // UI Actions\n    toggleDropdown,\n    closeDropdown,\n    \n    // Helpers\n    getNotificationIcon,\n    getNotificationTitle,\n    getNotificationMessage,\n    getNotificationActionUrl,\n    isNotificationUnread,\n    getNotificationPriorityClass,\n    formatNotificationTime,\n    \n    // Auto-refresh\n    startAutoRefresh,\n    stopAutoRefresh\n  }\n}"],"version":3}