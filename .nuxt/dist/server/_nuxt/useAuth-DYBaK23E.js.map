{"version":3,"file":"useAuth-DYBaK23E.js","sources":["../../../../node_modules/nuxt/dist/app/components/server-placeholder.js","../../../../node_modules/nuxt/dist/app/components/client-only.js","../../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../composables/useAuth.ts"],"sourcesContent":["import { createElementBlock, defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"ServerPlaceholder\",\n  render() {\n    return createElementBlock(\"div\");\n  }\n});\n","import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nimport { elToStaticVNode } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nconst STATIC_DIV = \"<div></div>\";\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  setup(props, { slots, attrs }) {\n    const mounted = shallowRef(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    const vm = getCurrentInstance();\n    if (vm) {\n      vm._nuxtClientOnly = true;\n    }\n    provide(clientOnlySymbol, true);\n    return () => {\n      if (mounted.value) {\n        const vnodes = slots.default?.();\n        if (vnodes && vnodes.length === 1) {\n          return [cloneVNode(vnodes[0], attrs)];\n        }\n        return vnodes;\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return h(slot);\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      }\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\n    };\n  } else {\n    clone.template &&= `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else>${STATIC_DIV}</template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = shallowRef(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 ||= {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            const res = setupState(...args);\n            const attrs = clone.inheritAttrs !== false ? ctx.attrs : void 0;\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res, attrs) : h(res, attrs);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { useHead } from \"./head.js\";\nexport function useRequestEvent(nuxtApp) {\n  if (import.meta.client) {\n    return;\n  }\n  nuxtApp ||= useNuxtApp();\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useHead({\n    script: [{\n      key: vm && key ? key : void 0,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? window.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { ref, computed, type Ref, type ComputedRef } from 'vue'\nimport { useCookie } from '#app'\n\n// Type definitions\nexport interface User {\n  id: string\n  name: string\n  email: string\n  email_verified_at?: string | null\n  avatar?: string | null\n  avatar_url?: string | null\n  phone?: string | null\n  created_at: string\n  updated_at: string\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n  remember?: boolean\n}\n\nexport interface RegisterData {\n  name: string\n  email: string\n  password: string\n  password_confirmation: string\n  phone?: string\n}\n\nexport interface AuthResponse {\n  success: boolean\n  user?: User\n  token?: string\n  error?: string\n}\n\nexport interface LoginResponse {\n  token: string\n  user: User\n}\n\nexport interface RegisterResponse {\n  token: string\n  user: User\n}\n\n// Global state\nconst user: Ref<User | null> = ref(null)\nconst token: Ref<string | null> = ref(null)\nconst isLoading: Ref<boolean> = ref(false)\nconst lastActivity: Ref<number> = ref(Date.now())\n\nexport const useAuth = () => {\n  const tokenCookie = useCookie<string | null>('auth-token', {\n    default: () => null,\n    maxAge: 60 * 60 * 24 * 30, // 30 days\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    httpOnly: false // Must be false for client-side access\n  })\n\n  const userCookie = useCookie<User | null>('auth-user', {\n    default: () => null,\n    maxAge: 60 * 60 * 24 * 30, // 30 days\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    httpOnly: false // Must be false for client-side access\n  })\n\n  // Initialize from cookies\n  if (tokenCookie.value) {\n    token.value = tokenCookie.value\n  }\n  if (userCookie.value) {\n    user.value = userCookie.value\n  }\n\n  const isAuthenticated: ComputedRef<boolean> = computed(() => !!token.value && !!user.value)\n\n  const login = async (credentials: LoginCredentials): Promise<AuthResponse> => {\n    try {\n      isLoading.value = true\n      const config = useRuntimeConfig()\n      const response = await $fetch<LoginResponse>('/api/v1/login', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        body: credentials,\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      })\n\n      if (response.token && response.user) {\n        token.value = response.token\n        user.value = response.user\n        tokenCookie.value = response.token\n        userCookie.value = response.user\n        lastActivity.value = Date.now()\n        \n        return { success: true, user: response.user, token: response.token }\n      }\n      \n      return { success: false, error: 'Invalid response format' }\n    } catch (error: any) {\n      console.error('Login error:', error)\n      return { \n        success: false, \n        error: error.data?.message || 'Login failed. Please check your credentials.' \n      }\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const register = async (userData: RegisterData): Promise<AuthResponse> => {\n    try {\n      isLoading.value = true\n      const config = useRuntimeConfig()\n      const response = await $fetch<RegisterResponse>('/api/v1/register', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        body: userData,\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        }\n      })\n\n      if (response.token && response.user) {\n        token.value = response.token\n        user.value = response.user\n        tokenCookie.value = response.token\n        userCookie.value = response.user\n        lastActivity.value = Date.now()\n        \n        return { success: true, user: response.user, token: response.token }\n      }\n      \n      return { success: false, error: 'Invalid response format' }\n    } catch (error: any) {\n      console.error('Registration error:', error)\n      return { \n        success: false, \n        error: error.data?.message || 'Registration failed. Please try again.' \n      }\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const logout = async (): Promise<void> => {\n    try {\n      isLoading.value = true\n      const config = useRuntimeConfig()\n      \n      if (token.value) {\n        await $fetch('/api/v1/logout', {\n          method: 'POST',\n          baseURL: config.public.apiBase,\n          headers: {\n            'Authorization': `Bearer ${token.value}`,\n            'Accept': 'application/json'\n          }\n        })\n      }\n    } catch (error) {\n      console.error('Logout error:', error)\n    } finally {\n      // Clear state regardless of API call success\n      token.value = null\n      user.value = null\n      tokenCookie.value = null\n      userCookie.value = null\n      isLoading.value = false\n    }\n  }\n\n  const fetchUser = async (): Promise<User | null> => {\n    try {\n      isLoading.value = true\n      const config = useRuntimeConfig()\n      \n      if (!token.value) {\n        return null\n      }\n\n      const response = await $fetch<User>('/api/v1/user', {\n        baseURL: config.public.apiBase,\n        headers: {\n          'Authorization': `Bearer ${token.value}`,\n          'Accept': 'application/json'\n        }\n      })\n\n      user.value = response\n      userCookie.value = response\n      lastActivity.value = Date.now()\n      return response\n    } catch (error) {\n      console.error('Fetch user error:', error)\n      // If token is invalid, clear auth state\n      await logout()\n      return null\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const updateLastActivity = (): void => {\n    lastActivity.value = Date.now()\n  }\n\n  const isTokenExpired = (): boolean => {\n    if (!token.value) return true\n    \n    // Check if last activity was more than 24 hours ago\n    const maxAge = 24 * 60 * 60 * 1000 // 24 hours in milliseconds\n    return Date.now() - lastActivity.value > maxAge\n  }\n\n  const refreshToken = async (): Promise<boolean> => {\n    try {\n      if (!token.value) return false\n      \n      const config = useRuntimeConfig()\n      const response = await $fetch<{ token: string }>('/api/v1/refresh', {\n        method: 'POST',\n        baseURL: config.public.apiBase,\n        headers: {\n          'Authorization': `Bearer ${token.value}`,\n          'Accept': 'application/json'\n        }\n      })\n\n      if (response.token) {\n        token.value = response.token\n        tokenCookie.value = response.token\n        lastActivity.value = Date.now()\n        return true\n      }\n      \n      return false\n    } catch (error) {\n      console.error('Token refresh error:', error)\n      await logout()\n      return false\n    }\n  }\n\n  return {\n    // State\n    user: readonly(user),\n    token: readonly(token),\n    isLoading: readonly(isLoading),\n    lastActivity: readonly(lastActivity),\n    \n    // Computed\n    isAuthenticated,\n    \n    // Actions\n    login,\n    register,\n    logout,\n    fetchUser,\n    updateLastActivity,\n    isTokenExpired,\n    refreshToken\n  }\n}"],"names":[],"mappings":"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","x_google_ignoreList":[0,1,2,3]}